<html lang="en">
<head>
    <title>Oimo Physics</title>
    <style>
        body {
          padding: 0;
          margin: 0;
          background-color: #000;
          margin: 0;
        }   
    </style>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/oimo.js"></script>
</head>
<body>
<script>

let content;
let aspect = window.innerWidth / window.innerHeight;
let radius = 60;

let camera = new THREE.PerspectiveCamera( 45, aspect, 1, 20000 );
camera.position.set( 0.0, radius * 6, radius * 6.5 );

let rayCaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let scene = new THREE.Scene();

renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( this.renderer.domElement );

let controls = new THREE.OrbitControls( camera, this.renderer.domElement );
controls.target.set( 0, 20, 0 );

let ctx = renderer.context;
ctx.getShaderInfoLog = function () { return '' };
       
//Light
scene.add( new THREE.AmbientLight( 0xffffff ) );
let lightOffset = new THREE.Vector3( 0, 1000, 1000.0 ); 
let light = new THREE.DirectionalLight( 0x333333, 1.5 );
scene.add( light );

//let helper = new THREE.CameraHelper( light.shadow.camera );
//scene.add( helper );

// physics
let world = new OIMO.World( { info:false, worldscale:100 } );
world.gravity = new OIMO.Vec3( 0, -9.8, 0 );

// -------- Pitch ---------   
new THREE.ObjectLoader().load( "models/pitch/stadium.json", function( pitch ) {
    
    // Pitch Base look in the plus          
    //materials[0].side = THREE.DoubleSide;                 
    //let ground =  new THREE.Mesh( geometry, materials[0] );
    //ground.scale.set( 20, 20, 20 );
    //ground.receiveShadow = true;
    //scope.scene.add( ground );

    pitch.position.set( -50, -30, -100 );
    pitch.scale.set( 800, 800, 800 );

    content = new THREE.Object3D();
    content.add( pitch );
    scene.add( content ); 

});

// The Bit of a collision group
let group1 = 1 << 0;  // 00000000 00000000 00000000 00000001
let group2 = 1 << 1;  // 00000000 00000000 00000000 00000010
let group3 = 1 << 2;  // 00000000 00000000 00000000 00000100
let all = 0xffffffff; // 11111111 11111111 11111111 11111111

// All the physics setting for rigidbody
let config = [
    1, // The density of the shape.
    0.4, // The coefficient of friction of the shape.
    0.2, // The coefficient of restitution of the shape.
    1, // The bits of the collision groups to which the shape belongs.
    all // The bits of the collision groups with which the shape collides.
];

//add ground
let ground = world.add( { size:[ 6000, 40, 5000 ], pos:[ 0, -20, 0 ], config:config } );

// add walls
let walls = new Array();
let wallsBody = new Array();
let matWall = new THREE.MeshBasicMaterial( { color: 0x004400 } );
let buffgeoWall = new THREE.BufferGeometry();

let wallLeft = { x: 0, y: 15, z: -1950, w: 6000, h: 150, d: 10 };
let wallRight = { x: 0, y: 15, z: 1950, w: 6000, h: 150, d: 10 };
let wallTop = { x: -3000, y: 15, z: 0, w: 10, h: 150, d: 3900 };
let wallBottom = { x: 3000, y: 15, z: 0, w: 10, h: 150, d: 3900 };

walls.push( new THREE.Mesh( new THREE.BoxGeometry( wallLeft.w, wallLeft.h, wallLeft.d ), matWall ) );
//scene.add( walls[0] );

walls.push( new THREE.Mesh( new THREE.BoxGeometry( wallRight.w, wallRight.h, wallRight.d ), matWall ) );
//scene.add( walls[1] );

walls.push( new THREE.Mesh( new THREE.BoxGeometry( wallTop.w, wallTop.h, wallTop.d ), matWall ) );
//scene.add( walls[2] );

walls.push( new THREE.Mesh( new THREE.BoxGeometry( wallBottom.w, wallBottom.h, wallBottom.d ), matWall ) );
//scene.add( walls[3] );

wallsBody.push( world.add( { size:[ wallLeft.w, wallLeft.h, wallLeft.d ], pos:[ wallLeft.x, wallLeft.y, wallLeft.z ], move:false, config:config, name:'wallLeft' } ) );
walls[0].position.copy( wallsBody[0].getPosition() );
walls[0].quaternion.copy( wallsBody[0].getQuaternion() );

wallsBody.push( world.add( { size:[ wallRight.w, wallRight.h, wallRight.d ], pos:[ wallRight.x, wallRight.y, wallRight.z ], move:false, config:config, name:'wallright' } ) );
walls[1].position.copy( wallsBody[1].getPosition() );
walls[1].quaternion.copy( wallsBody[1].getQuaternion() );

wallsBody.push( world.add( { size:[ wallTop.w, wallTop.h, wallTop.d ], pos:[ wallTop.x, wallTop.y, wallTop.z ], move:false, config:config, name:'wallTop' } ) );
walls[2].position.copy( wallsBody[2].getPosition() );
walls[2].quaternion.copy( wallsBody[2].getQuaternion() );

wallsBody.push( world.add( { size:[ wallBottom.w, wallBottom.h, wallBottom.d ], pos:[ wallBottom.x, wallBottom.y, wallBottom.z ], move:false, config:config, name:'wallBottom' } ) );
walls[3].position.copy( wallsBody[3].getPosition() );
walls[3].quaternion.copy( wallsBody[3].getQuaternion() );

// ball mesh
let x = 0;
let z = 0;
let y = 100;
let w = 10;
let h = 10;
let d = 10;

let buffgeoSphere = new THREE.BufferGeometry();
buffgeoSphere.fromGeometry( new THREE.SphereGeometry( 1, 20, 10 ) );

let textureBall = new THREE.TextureLoader().load('images/ball.png');                    
let materialBall = new THREE.MeshBasicMaterial( { color: 0xffffff, map: textureBall } );

ball3D = new THREE.Mesh( buffgeoSphere, materialBall );
ball3D.scale.set( w, w, w );
ball3D.castShadow = true;
ball3D.receiveShadow = true;
scene.add( ball3D );                

//ball body
config[3] = group2;
config[4] = all;
ball3DBody = world.add( { type:'sphere', size:[ w ], pos:[ x, y, z ], move:true, config:config, name:'sphere' } );

// paddle raycaster
let vPaddle = new THREE.Object3D();

// paddle mesh
let matBoxHit = new THREE.MeshBasicMaterial( { color: 0x383838 } );
let matBox = new THREE.MeshBasicMaterial( { color: 0x58AA80 } );
let buffgeoBox = new THREE.BufferGeometry();
buffgeoBox.fromGeometry( new THREE.BoxGeometry( 1, 1, 1 ) );

paddle = new THREE.Mesh( buffgeoBox, matBox );
paddle.scale.set( 20, 40, 60 );
scene.add( paddle );

// paddle body
config[3] = 1;
config[4] = all;
paddleBody = world.add( { size:[ 20, 40, 60 ], pos:[ -150, 20, 0 ], rot:[ 0, 0, 0 ], move:true, noSleep:true, config:config, name:'paddle', kinematic:true } );

function updateOimoPhysics() {

    world.step();

    // apply new position on last rigidbody
    paddleBody.setPosition( vPaddle.position );

    vPaddle.lookAt( new THREE.Vector3( 100, vPaddle.position.y, 0 ) );
    vPaddle.rotation.y += Math.PI/2;

    // apply new rotation on last rigidbody
    paddleBody.setQuaternion( vPaddle.quaternion );        

    ball3D.position.copy( ball3DBody.getPosition() );
    ball3D.quaternion.copy( ball3DBody.getQuaternion() );

    paddle.position.copy( paddleBody.getPosition() );
    paddle.quaternion.copy( paddleBody.getQuaternion() );

    // reset position
    if( ball3D.position.y < -100 ){
        let x = 0;
        let z = 0;
        let y = 100 + Math.random() * 100;
        ball3DBody.resetPosition( x, y, z );
    };

    // contact test
    if( world.checkContact( 'paddle', 'sphere' ) ) {
        paddle.material = matBox;
    } else {
        paddle.material = matBoxHit;
    };

};

function loop() {
    requestAnimationFrame( loop );
    updateOimoPhysics();
    renderer.render( scene, camera );
};

loop();

//----------------------------------
//  RAY TEST
//----------------------------------
function rayTest( e ) {

    mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

    rayCaster.setFromCamera( mouse, camera );
    let intersects = rayCaster.intersectObjects( content.children, true );

    if ( intersects.length ) {
        vPaddle.position.copy( intersects[ 0 ].point.add( new THREE.Vector3( 0, 20, 0 ) ) );
    };

};

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
};

// events
window.addEventListener( 'resize', onWindowResize, false );
window.addEventListener( 'mousemove', rayTest, false );

</script>

</body>
</html>

<html>
    <head>
        <meta charset="utf-8">
        <title>cannon.js + three.js physics shooter</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                font-family: arial;
            }

            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;

                cursor: pointer;

            }

        </style>
    </head>
    <body>
        <script src="js/Three.js"></script>
        <script src="js/cannon.js"></script>
        <script src="js/dat.gui.min.js"></script>
        <script src="js/PointerLockControls.js"></script>

        <div id="container"></div>
        <div id="blocker">

            <div id="instructions">
                <span style="font-size:40px">Click to play</span>
                <br />
                (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot)
            </div>

        </div>

        <script>
			'use strict';

        	class Shooter{

        		constructor(){

		            this.walls = new Array();
		            this.balls = new Array();
		            this.ballMeshes = new Array();

		            this.boxMeshes = new Array();
		            this.boxes = new Array();

		            this.time = Date.now();

       	            this.dt = 1/60;
		            this.ballShape = new CANNON.Sphere( 0.2 );
		            this.ballGeometry = new THREE.SphereGeometry( this.ballShape.radius, 32, 32 );
	    	        this.shootDirection = new THREE.Vector3();
	        	    
	        	    this.shootVelo = 15;

		            let blocker = document.getElementById( 'blocker' );
		            let instructions = document.getElementById( 'instructions' );

		            let element = document.body;

		            let pointerlockchange = function ( event ) {

		                if ( document.pointerLockElement === element ) {
		                    this.controls.enabled = true;
		                    blocker.style.display = 'none';

		                } else {
		                    this.controls.enabled = false;
		                    blocker.style.display = 'box';
		                    instructions.style.display = '';
		                };

		            };

		            let pointerlockerror = function ( event ) {
		                instructions.style.display = '';
		            };

		            // Hook pointer lock state change events
		            document.addEventListener( 'pointerlockchange', pointerlockchange.bind( this ), false );
		            document.addEventListener( 'pointerlockerror', pointerlockerror.bind( this ), false );

		            instructions.addEventListener( 'click', function ( event ) {
		                instructions.style.display = 'none';
		                // Ask the browser to lock the pointer
		                element.requestPointerLock = element.requestPointerLock;
		                element.requestPointerLock();

		            }, false );


		            window.addEventListener( "click", function( e ){

		                if( this.controls.enabled == true ){
		                    let x = this.sphereBody.position.x;
		                    let y = this.sphereBody.position.y;
		                    let z = this.sphereBody.position.z;
		                    let ballBody = new CANNON.Body( { mass: 1 } );
		                    ballBody.addShape( this.ballShape );
		                    let ballMesh = new THREE.Mesh( this.ballGeometry, this.material );
		                    this.world.addBody( ballBody );
		                    this.scene.add( ballMesh );
		                    ballMesh.castShadow = true;
		                    ballMesh.receiveShadow = true;
		                    this.balls.push( ballBody );
		                    this.ballMeshes.push( ballMesh );
		                    this.getShootDir( this.shootDirection );
		                    ballBody.velocity.set( this.shootDirection.x * this.shootVelo,
		                                           this.shootDirection.y * this.shootVelo,
		                                           this.shootDirection.z * this.shootVelo );

		                    // Move the ball outside the player sphere
		                    x += this.shootDirection.x * ( this.sphereShape.radius * 1.02 + this.ballShape.radius );
		                    y += this.shootDirection.y * ( this.sphereShape.radius * 1.02 + this.ballShape.radius );
		                    z += this.shootDirection.z * ( this.sphereShape.radius * 1.02 + this.ballShape.radius );
		                    ballBody.position.set( x, y, z );
		                    ballMesh.position.set( x, y, z );
		                };

		            }.bind( this ) );

            		this.initCannon();
            		this.init();
            		this.render();

		 		};

	            initCannon(){

	                // Setup our world
	                this.world = new CANNON.World();
	                this.world.quatNormalizeSkip = 0;
	                this.world.quatNormalizeFast = false;

	                let solver = new CANNON.GSSolver();

	                this.world.defaultContactMaterial.contactEquationStiffness = 1e9;
	                this.world.defaultContactMaterial.contactEquationRelaxation = 4;

	                solver.iterations = 7;
	                solver.tolerance = 0.1;
	 
	                this.world.solver = new CANNON.SplitSolver( solver );
	 
	                this.world.gravity.set( 0, -20, 0 );
	                this.world.broadphase = new CANNON.NaiveBroadphase();

	                // Create a slippery material (friction coefficient = 0.0)
	                let physicsMaterial = new CANNON.Material( "slipperyMaterial" );
	                let physicsContactMaterial = new CANNON.ContactMaterial( physicsMaterial,
	                                                                         physicsMaterial,{
	                                                                         	friction: 1.5, // friction coefficient
	                                                                         	restitution: 0.3  // restitution
	                                                                     	 }
	                                                                       	);
	                // We must add the contact materials to the world
	                this.world.addContactMaterial( physicsContactMaterial );

	                // Create a sphere
	                let mass = 5, radius = 1.3;
	                this.sphereShape = new CANNON.Sphere( radius );
	                this.sphereBody = new CANNON.Body( { mass: mass } );
	                this.sphereBody.addShape( this.sphereShape );
	                this.sphereBody.position.set( 0, 5, 0 );
	                this.sphereBody.linearDamping = 0.9;
	                this.world.addBody( this.sphereBody );

	                // Create a plane
	                let groundShape = new CANNON.Plane();
	                let groundBody = new CANNON.Body({ mass: 0 });
	                groundBody.addShape(groundShape);
	                groundBody.quaternion.setFromAxisAngle( new CANNON.Vec3( 1, 0, 0 ), -Math.PI/2 );
	                this.world.addBody( groundBody );
	            };

	            init() {

	            	// Note: coordinate unit of 1 = 1 meter
					this.shotControl = {
					    dt: 0.001, //seconds
					    displaySpeed: 1.0, // display time multiplier
					    initSpeedMPS: 25,
					    initVerticalAngleDegrees: 20,
					    initHorizontalAngleDegrees: 0,
					    initBackspinRPM: 6000,
					    initSpinAngle: 0,
					    shoot: this.beginShot.bind( this )
					};

					let gui = new dat.GUI( { autoPlace: true } );
					document.body.appendChild( gui.domElement );
					gui.add( this.shotControl, 'initSpeedMPS', 5, 80 );
					gui.add( this.shotControl, 'initVerticalAngleDegrees', 0, 90 );
					gui.add( this.shotControl, 'initHorizontalAngleDegrees', -45, 45 );
					gui.add( this.shotControl, 'initBackspinRPM', 0, 6000 );
					gui.add( this.shotControl, 'initSpinAngle', -45, 45 );
					gui.add( this.shotControl, 'displaySpeed', 0, 5 );
					gui.add( this.shotControl, 'shoot' );

	                this.camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
	                this.scene = new THREE.Scene();

	                let ambient = new THREE.AmbientLight( 0x111111 );
	                this.scene.add( ambient );

	                this.light = new THREE.SpotLight( 0xffffff );
	                this.light.position.set( 10, 30, 20 );
	                this.light.target.position.set( 0, 0, 0 );
	                
	                if( true ){
	                    this.light.castShadow = true;

	                    this.light.shadowCameraNear = 20;
	                    this.light.shadowCameraFar = 50;//camera.far;
	                    this.light.shadowCameraFov = 40;

	                    this.light.shadowMapBias = 0.1;
	                    this.light.shadowMapDarkness = 0.7;
	                    this.light.shadowMapWidth = 2*512;
	                    this.light.shadowMapHeight = 2*512;

	                    //light.shadowCameraVisible = true;
	                };
	                
	                this.scene.add( this.light );

	                this.controls = new PointerLockControls( this.camera, this.sphereBody );
	                this.scene.add( this.controls.getObject() );

	                // floor
	                let geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
	                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	                this.material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );

	                let mesh = new THREE.Mesh( geometry, this.material );
	                mesh.castShadow = true;
	                mesh.receiveShadow = true;
	                this.scene.add( mesh );

	                this.renderer = new THREE.WebGLRenderer( { alpha:true } );
	                this.renderer.shadowMapEnabled = true;
	                this.renderer.shadowMapSoft = true;
	                this.renderer.setSize( window.innerWidth, window.innerHeight );

	                document.body.appendChild( this.renderer.domElement );

	                window.addEventListener( 'resize', this.onWindowResize.bind( this ), false );

	                // Add boxes
	                let halfExtents = new CANNON.Vec3( 1,1 , 1 );
	                let boxShape = new CANNON.Box( halfExtents );
	                let boxGeometry = new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 );

	                for( let i = 0; i < 7; i++ ){

	                    let x = ( Math.random() -0.5 ) * 20;
	                    let y = 1 + ( Math.random() -0.5 ) * 1;
	                    let z = ( Math.random() -0.5 ) * 20;
	                    let boxBody = new CANNON.Body( { mass: 5 } );
	                    boxBody.addShape( boxShape );
	                    let boxMesh = new THREE.Mesh( boxGeometry, this.material );
	                    this.world.addBody( boxBody );
	                    this.scene.add( boxMesh );
	                    boxBody.position.set( x, y, z );
	                    boxMesh.position.set( x, y, z );
	                    boxMesh.castShadow = true;
	                    boxMesh.receiveShadow = true;
	                    this.boxes.push( boxBody );
	                    this.boxMeshes.push( boxMesh );
	                };

	                // Add linked boxes
	                let size = 0.5;
	                let he = new CANNON.Vec3( size, size, size * 0.1 );
	                let mass = 0;
	                let space = 0.1 * size;
	                let N = 5, last;
	                
	                boxShape = new CANNON.Box( he );
	                boxGeometry = new THREE.BoxGeometry( he.x * 2, he.y * 2, he.z * 2 );

	                for( let i = 0; i < N; i++ ){

	                    let boxbody = new CANNON.Body( { mass: mass } );
	                    let boxMesh = new THREE.Mesh( boxGeometry, this.material );

	                    boxbody.addShape( boxShape );
	                    boxbody.position.set( 5, ( N - i ) * ( size * 2 + 2 * space ) + size * 2 + space, 0 );
	                    boxbody.linearDamping = 0.01;
	                    boxbody.angularDamping = 0.01;

	                    // boxMesh.castShadow = true;
	                    boxMesh.receiveShadow = true;

	                    this.world.addBody( boxbody );
	                    this.scene.add( boxMesh );
	                    this.boxes.push( boxbody );
	                    this.boxMeshes.push( boxMesh );

	                    if( i != 0 ){

	                        // Connect this body to the last one
	                        let c1 = new CANNON.PointToPointConstraint( boxbody, new CANNON.Vec3( -size,size+space, 0 ), last, new CANNON.Vec3( -size, -size-space, 0 ) );
	                        let c2 = new CANNON.PointToPointConstraint( boxbody, new CANNON.Vec3( size,size+space, 0 ), last, new CANNON.Vec3( size, -size-space, 0 ) );
	                        this.world.addConstraint( c1 );
	                        this.world.addConstraint( c2 );
	                    
	                    } else {
	                    
	                        mass = 0.3;
	                    
	                    };

	                    last = boxbody;
	                };
	            };

	            onWindowResize() {

	                this.camera.aspect = window.innerWidth / window.innerHeight;
	                this.camera.updateProjectionMatrix();
	                this.renderer.setSize( window.innerWidth, window.innerHeight );
	            
	            };

	            render() {

	            	const render = this.render.bind( this );
	                requestAnimationFrame( render );

	                if( this.controls.enabled ){

	                    this.world.step( this.dt );

	                    // Update ball positions
	                    for( let i = 0; i < this.balls.length; i++ ){
	                        this.ballMeshes[i].position.copy( this.balls[i].position );
	                        this.ballMeshes[i].quaternion.copy( this.balls[i].quaternion );
	                    };

	                    // Update box positions
	                    for( let i = 0; i < this.boxes.length; i++ ){
	                        this.boxMeshes[i].position.copy( this.boxes[i].position );
	                        this.boxMeshes[i].quaternion.copy( this.boxes[i].quaternion );
	                    };

	                };

	                this.controls.update( Date.now() - this.time );
	                this.renderer.render( this.scene, this.camera );
	                this.time = Date.now();

	            };

	            getShootDir( targetVec ){

	                let vector = targetVec;
	                targetVec.set( 0, 0, 1 );

					vector.unproject( this.camera );

	                let ray = new THREE.Ray( this.sphereBody.position, vector.sub( this.sphereBody.position ).normalize() );
	                targetVec.copy( ray.direction );

	            };

	            beginShot(){

	            };

			};

			let shooter = new Shooter();

        </script>
    </body>
</html>

<html>
    <head>
        <meta charset="utf-8">
        <title>cannon.js + three.js physics shooter</title>
        <style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #000;
				margin: 0;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#display-container {
				width: 100%;      
				height: 100%;
			}

			#status-display {
				position: absolute;
				bottom: 100px;
				right: 20px;
				color: cyan;
			}

			#status-display ul {
				list-style-type: none;
			}

			#stats {
				position: absolute;
				top: 15px;
				left: 15px;
			}

			div .dg {
				position: absolute;
				top: 20px;
				right: 20px;    
			}

			.virtualButton{
				font-family: "Lucida Grande", Tahoma, Verdana, sans-serif;
				position: absolute;
				font-weight: 800;
				right: 120px;
				bottom: 90px;
				width: 65px; 
				height: 65px;
				display: flex;
				justify-content: center;
				align-items: center;
				cursor: pointer;
				background: rgba( 255, 255, 255, .5 );
				border-radius: 50%;
				-ms-touch-action: none;
				touch-action: none;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}

			#menu {
				font-family: helvetica;
				position: absolute;
				left:20px;
				top: 10px;
				color: #ffffff;
				z-index: 2;
			}      

        </style>
    </head>
    <body>
        <script src="js/Three.js"></script>
        <script src="js/cannon.js"></script>
        <script src="js/dat.gui.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/VirtualJoystick.js"></script>

        <link rel="stylesheet" type="text/css" media="screen,print" href="css/virtualJoystick.css">

	    <div id="menu">
	      <label><input type="radio" name="action" id="eventRotate">Rotate World</label>
	      <label><input type="radio" name="action" id="eventDrag">Drag</label>
	      <label><input type="radio" name="action" id="eventAdd">Add</label>
	      <label><input type="radio" name="action" id="eventDelete">Delete</label>
	    </div>

        <div id="container"></div>
   		<div id="joystickStatic"></div>
	    <div class="virtualButton" id="buttonShoot">Shoot</div>    
	    <script>
	      document.getElementById("buttonShoot").addEventListener( "click", function() {
	        scene3D.beginShot();
	      });

		      let joystick = new Array();
		
		      joystick.push( new VirtualJoystick( {
		                container: document.getElementById( 'joystickStatic' ),
		                maxTravel: 32,
		                style: "virtualJoystic-stick",
		                static: true
		              } )
		      );

		 /*
		      joystick.push( new VirtualJoystick( {
		                container: document.getElementById( 'joystickDynamic' ),
		                maxTravel: 3200,
		                style: "virtualJoystic-stick",
		                static: false   
		              } )
		      );
		*/	      
	    </script>

	  	<div id="status-display">
	  		<ul>
	  			<li id="status-time"></li>
	  			<li id="status-distance"></li>
	  			<li id="status-speed"></li>
	  			<li id="status-height"></li>
	  			<li id="status-spin"></li>
	  		</ul>
	  	</div>        

        <script>

			'use strict';

			class Shot {

			    constructor( options = {} ) {

			        this.points = new Array();
			        let initPoint = new ShotPoint();
			        initPoint.position = new THREE.Vector3( 0, 0, 0 );

			        // ball properties
			        this.mass = 0.459; // kg;
			        this.crossSectionalArea = 0.04267 * Math.PI / 4; //m^2
			        this.smashFactor = ( options.smashFactor == null ) ? 1.49 : options.smashFactor; // ball initial speed ratio

			        // nature
			        this.gravityMagnitude = -9.8; // 9.8 m/s^2
			        this.airDensity = 1.2041; // kg/m^3

			        // ball aerodynamics properties        
			        this.dragCoefficient = ( options.dragCoefficient == null ) ? 0.4 : options.dragCoefficient;
			        this.liftCoefficient = ( options.liftCoefficient == null ) ? 0.00001 : options.liftCoefficient; // made this up?
			        this.spinDecayRateConstant = 23; // made this up?

			        // initial shot attributes
			        this.initSpeedMPS = options.initSpeedMPS || 0.0;
			        this.initVerticalAngleDegrees = options.initVerticalAngleDegrees || 0.0;
			        this.initHorizontalAngleDegrees = options.initHorizontalAngleDegrees || 0.0;
			        this.initBackspinRPM = options.initBackspinRPM || 0.0;
			        this.initSpinAngle = options.initSpinAngle || 0.0;

			        // simulation properties
			        this.dt = options.dt || 0.001; //seconds

			        // initial velocity        
			        initPoint.velocity = this.getInitialVelocity( this.initSpeedMPS, this.smashFactor, this.initVerticalAngleDegrees, this.initHorizontalAngleDegrees );

			        // initial angular velocity (spin rate)
			        initPoint.angularVelocity = this.getInitialSpin( this.initBackspinRPM, this.initSpinAngle );

			        this.projectShot( initPoint );

			    };

			    getInitialSpin( spinRPM, spinAngle ) {
			        let spin = new THREE.Vector3(0, 0, 0);
			        spin.x = -1; // full backspin
			        spin.y = Math.sin( spinAngle * Math.PI / 180 );

			        spin.normalize().multiplyScalar( spinRPM * 2 * Math.PI / 60 );

			        return spin;
			    };

			    getInitialVelocity( speedMPS, smashFactor, verticalDegrees, horizontalDegrees ) {

			        let velocity = new THREE.Vector3( 0, 0, 0 );
			        velocity.x = Math.sin( horizontalDegrees * Math.PI / 180 );
			        velocity.y = Math.sin( verticalDegrees * Math.PI / 180 );
			        velocity.z = Math.cos( verticalDegrees * Math.PI / 180 );

			        let ballSpeed = speedMPS * smashFactor;        

			        return velocity.normalize().multiplyScalar( ballSpeed );
			    };

			    projectShot( initPoint ) {

			        // initial point
			        let lastPoint = initPoint.clone();
			        this.points.push( lastPoint ); 

			        while( true ) {
			            let newPoint = lastPoint.clone();

			            // calculate velocity change            
			            let accel = this.getAcceleration( lastPoint );
			            newPoint.velocity.add( accel.clone().multiplyScalar( this.dt ) );
			            newPoint.position.add( newPoint.velocity.clone().multiplyScalar( this.dt ) );

			            // calculate spin rate decay
			            let decayRate = this.angularDecayVector( newPoint );
			            newPoint.angularVelocity.add( decayRate );

			            this.points.push( newPoint ); 

			            if ( newPoint.position.y <= 0 ) {
			                break;
			            };

			            lastPoint = newPoint;
			        };
			    };

			    getAcceleration( currentPoint ) {

			        // gravity: -9.8 m/s^2
			        let gravityAcceleration = new THREE.Vector3( 0, this.gravityMagnitude, 0 );

			        // drag acceleration = drag force / mass
			        let adjustedDragCoefficient = this.dragCoefficient * Math.min( 1.0, 14 / currentPoint.velocity.length() );
			        let dragForceAcceleration = currentPoint.velocity.clone().multiplyScalar( -1 * adjustedDragCoefficient * this.airDensity * this.crossSectionalArea / this.mass );

			        // magnus acceleration (from ball spin) = magnus force / mass
			        let magnusForceAcceleration = currentPoint.angularVelocity.clone().cross( currentPoint.velocity).multiplyScalar( this.liftCoefficient / this.mass );

			        // combined acceleration = gravity + drag + magnus
			        let totalAccel = ( new THREE.Vector3( 0, 0, 0 ) ).add( gravityAcceleration ).add( dragForceAcceleration ).add( magnusForceAcceleration );

			        return totalAccel;

			    };

			    angularDecayVector( currentPoint ) {

			        let decay = currentPoint.angularVelocity.clone();
			        decay.normalize().negate().multiplyScalar( this.spinDecayRateConstant * this.dt );
			        return decay;

			    };

			};

			class ShotPoint {

			    constructor() {

			        this.position = new THREE.Vector3( 0, 0 ,0 );
			        this.velocity = new THREE.Vector3( 0, 0, 0 );
			        this.angularVelocity = new THREE.Vector3( 0, 0, 0 );
			        this.acceleration = new THREE.Vector3( 0, 0, 0 );

			    };

			    clone() {

			        let point = new ShotPoint();
			        point.position = this.position.clone();
			        point.velocity = this.velocity.clone();
			        point.acceleration = this.acceleration.clone();
			        point.angularVelocity = this.angularVelocity.clone();
			        return point;

			    };

			};


			'use strict';

        	class Shooter{

        		constructor(){

		            this.walls = new Array();
		            this.balls = new Array();
		            this.ballMeshes = new Array();

		            this.boxMeshes = new Array();
		            this.boxes = new Array();

       	            this.dt = 1/60;
		            this.ballShape = new CANNON.Sphere( 0.2 );
		            this.ballGeometry = new THREE.SphereGeometry( this.ballShape.radius, 32, 32 );
	    	        this.shootDirection = new THREE.Vector3();
	        	    
	        	    this.shootVelo = 15;

		 		};

	            initCannon(){

	                // Setup our world
	                this.world = new CANNON.World();
	                this.world.quatNormalizeSkip = 0;
	                this.world.quatNormalizeFast = false;

	                let solver = new CANNON.GSSolver();

	                this.world.defaultContactMaterial.contactEquationStiffness = 1e9;
	                this.world.defaultContactMaterial.contactEquationRelaxation = 4;

	                solver.iterations = 7;
	                solver.tolerance = 0.1;
	 
	                this.world.solver = new CANNON.SplitSolver( solver );
	 
	                this.world.gravity.set( 0, -20, 0 );
	                this.world.broadphase = new CANNON.NaiveBroadphase();

	                // Create a slippery material (friction coefficient = 0.0)
	                let physicsMaterial = new CANNON.Material( { name: "slipperyMaterial", friction: 0.4, restitution: 0.3 } );
	                let physicsContactMaterial = new CANNON.ContactMaterial( physicsMaterial, physicsMaterial, { friction: 0.5, restitution: 0.3 } );

	                this.world.addContactMaterial( physicsContactMaterial );

	                // Create a sphere
	                let mass = 10, radius = 1.3;
	                this.sphereShape = new CANNON.Sphere( radius );
	                this.sphereBody = new CANNON.Body( { mass: mass, material: physicsMaterial  } );
	                this.sphereBody.addShape( this.sphereShape );
	                this.sphereBody.position.set( 0, 5, 0 );
	                this.sphereBody.linearDamping = 0.9;
	                this.world.addBody( this.sphereBody );

	                // Create a plane
	                let groundShape = new CANNON.Plane();
	                let groundBody = new CANNON.Body( { mass: 0, material: physicsMaterial } );
	                groundBody.addShape( groundShape );
	                groundBody.quaternion.setFromAxisAngle( new CANNON.Vec3( 1, 0, 0 ), -Math.PI/2 );
	                this.world.addBody( groundBody );

	            };

	            initGeometry() {

	                // floor
	                let geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
	                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	                this.material = new THREE.MeshLambertMaterial( { color: 0x000000 } );

	                let mesh = new THREE.Mesh( geometry, this.material );
	                mesh.castShadow = true;
	                mesh.receiveShadow = true;

	                this.scene.add( mesh );

	                // Add boxes
	                /*
	                this.material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
	                let halfExtents = new CANNON.Vec3( 1, 1, 1 );
	                let boxShape = new CANNON.Box( halfExtents );
	                let boxGeometry = new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 );

	                for( let i = 0; i < 7; i++ ){

	                    let x = ( Math.random() -0.5 ) * 20;
	                    let y = 1 + ( Math.random() -0.5 ) * 1;
	                    let z = ( Math.random() -0.5 ) * 20;
	                    let boxBody = new CANNON.Body( { mass: 5 } );
	                    boxBody.addShape( boxShape );
	                    let boxMesh = new THREE.Mesh( boxGeometry, this.material );
	                    this.world.addBody( boxBody );
	                    this.scene.add( boxMesh );
	                    boxBody.position.set( x, y, z );
	                    boxMesh.position.set( x, y, z );
	                    boxMesh.castShadow = true;
	                    boxMesh.receiveShadow = true;
	                    this.boxes.push( boxBody );
	                    this.boxMeshes.push( boxMesh );

	                };
	                */

	            };

	            getShootDir( targetVec ){

	                let vector = targetVec;
	                targetVec.set( 0, 0, 1 );

					vector.unproject( this.camera );

	                let ray = new THREE.Ray( this.sphereBody.position, vector.sub( this.sphereBody.position ).normalize() );
	                
	                //targetVec.copy( ray.direction );

	                targetVec.set( ray.direction.x, Math.PI / 4, ray.direction.y )

	            };

			};

			//let shooter = new Shooter();

			class Scene3D extends Shooter {

				constructor(){

					super();
					this.points = new Array();
					this.shot;
					this.line;

					this.sceneZOffset;
					this.displayStartTime;
					this.displaySpeed;
					
					// add renderer
					this.renderer = new THREE.WebGLRenderer( { antialias: true, alpha:true } );
					this.renderer.setSize( window.innerWidth, window.innerHeight )
					
					// add container
					this.container = document.getElementById( 'container' );
					this.container.appendChild( this.renderer.domElement );

					// status elements
					this.statusElementTime = document.getElementById( 'status-time' );
					this.statusElementSpeed = document.getElementById( 'status-speed' );
					this.statusElementHeight = document.getElementById( 'status-height' );
					this.statusElementDistance = document.getElementById( 'status-distance' );
					this.statusElementSpin = document.getElementById( 'status-spin' );

					this.scene = new THREE.Scene();
					
					let aspect = window.innerWidth / window.innerHeight;
					//let radius = player.geometry.boundingSphere.radius;
					let radius = 60;

					this.camera = new THREE.PerspectiveCamera( 45, aspect, 1, 20000 );
					this.camera.position.set( 0.0, radius * 1.5, radius * 4.5 );

					// disable orbitControl to rotate a camera!!
					//this.camera.rotation.order = 'YXZ'
					//this.camera.rotation.y = 1.7;  // Y first
					//this.camera.rotation.x = 2.5;  // X second
					//this.camera.rotation.z = 1.8;

					this.angle = -0.5 * Math.PI;
					let x = this.camera.position.x;
					let z = this.camera.position.z;

			        this.camera.position.x = x * Math.cos( this.angle ) + z * Math.sin( this.angle );
			        this.camera.position.z = z * Math.cos( this.angle ) - x * Math.sin( this.angle );

			        this.camera.lookAt( this.scene.position );
				
					// remove shaderlog warnings
					let ctx = this.renderer.context;
					ctx.getShaderInfoLog = function () { return '' };
					   
					//controls
					this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
					this.controls.rotateSpeed = 1.0;
					this.controls.zoomSpeed = 1.2;
					this.controls.panSpeed = 0.8;
					
					const hLight = new THREE.HemisphereLight( 0xffffff );
					this.scene.add( hLight );

					// Note: coordinate unit of 1 = 1 meter
					this.shotControl = {
					    dt: 0.001, //seconds
					    displaySpeed: 1.0, // display time multiplier
					    initSpeedMPS: 25,
					    initVerticalAngleDegrees: 20,
					    initHorizontalAngleDegrees: 0,
					    initBackspinRPM: 6000,
					    initSpinAngle: 0,
					    shootVelo: 10,
					    VerticalAngle: Math.PI / 4,
					    HorizontalAngle: 0,
					    shoot: this.beginShot.bind( this )
					};

					let gui = new dat.GUI( { autoPlace: false } );
					this.container.appendChild( gui.domElement );
					gui.add( this.shotControl, 'initSpeedMPS', 5, 80 );
					gui.add( this.shotControl, 'initVerticalAngleDegrees', 0, 90 );
					gui.add( this.shotControl, 'initHorizontalAngleDegrees', -45, 45 );
					gui.add( this.shotControl, 'initBackspinRPM', 0, 6000 );
					gui.add( this.shotControl, 'initSpinAngle', -45, 45 );
					gui.add( this.shotControl, 'displaySpeed', 0, 5 );
					gui.add( this.shotControl, 'shootVelo', 5, 80 );
					gui.add( this.shotControl, 'VerticalAngle', 0, Math.PI / 2 );
					gui.add( this.shotControl, 'HorizontalAngle', -Math.PI / 4, Math.PI / 4 );
					gui.add( this.shotControl, 'shoot' );

					window.addEventListener( 'resize', function(){
				    	this.camera.aspect = window.innerWidth / window.innerHeight;
					    this.camera.updateProjectionMatrix();
				    	this.renderer.setSize( window.innerWidth, window.innerHeight );
					}.bind( this ), false );

					this.addInitialElements();

            		this.initCannon();
            		this.initGeometry();

					this.beginShot();
					this.render();

				};

				render() {

					const render = this.render.bind( this ); 
					requestAnimationFrame( render );
				
				    this.controls.update();
				    this.renderer.render( this.scene, this.camera );

				    if ( this.shot ) {
				        this.updateShot();
				    };

                    this.world.step( this.dt );

                    // Update ball positions
                    for( let i = 0; i < this.balls.length; i++ ){
                        this.ballMeshes[i].position.copy( this.balls[i].position );
                        this.ballMeshes[i].quaternion.copy( this.balls[i].quaternion );
                    };

                    // Update box positions
                    //for( let i = 0; i < this.boxes.length; i++ ){
                    //    this.boxMeshes[i].position.copy( this.boxes[i].position );
                    //    this.boxMeshes[i].quaternion.copy( this.boxes[i].quaternion );
                    //};

				    /*
					//MoveBall ?!?
					let heading = joystick[0].getHeading();
					
					if( heading.up == true ){
						this.ball3D.position.x += 0.1;
					};

					if( heading.down == true ){
						this.ball3D.position.x -= 0.1;
					};

					if( heading.left == true ){
						this.ball3D.position.z -= 0.1;
					};

					if( heading.right == true ){
						this.ball3D.position.z += 0.1;
					};
					*/

				};

				beginShot() {

					this.points.length = 0
				    this.shot = new Shot( this.shotControl );
				    this.points.push( this.shot.points[0] );
				    this.displaySpeed = this.shotControl.displaySpeed;
				    this.displayStartTime = Date.now();


                    let x = this.sphereBody.position.x;
                    let y = this.sphereBody.position.y;
                    let z = this.sphereBody.position.z;
                    let ballBody = new CANNON.Body( { mass: 1 } );
                    ballBody.addShape( this.ballShape );

                    this.material = new THREE.MeshLambertMaterial( { color: 0xff0000 } );
                    let ballMesh = new THREE.Mesh( this.ballGeometry, this.material );
                    this.world.addBody( ballBody );
                    this.scene.add( ballMesh );
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    this.balls.push( ballBody );
                    this.ballMeshes.push( ballMesh );
                    this.getShootDir( this.shootDirection );
                    ballBody.velocity.set( this.shootDirection.x * this.shootVelo,
                                           this.shootDirection.y * this.shootVelo,
                                           this.shootDirection.z * this.shootVelo );

                    // Move the ball outside the player sphere
                    x += this.shootDirection.x * ( this.sphereShape.radius * 1.02 + this.ballShape.radius );
                    y += this.shootDirection.y * ( this.sphereShape.radius * 1.02 + this.ballShape.radius );
                    z += this.shootDirection.z * ( this.sphereShape.radius * 1.02 + this.ballShape.radius );
                    ballBody.position.set( x, y, z );
                    ballMesh.position.set( x, y, z );

				};

				updateShot() {

				    let now = Date.now();
				    let rawTimeElapsed = now - this.displayStartTime;
				    let displayTimeElapsed = Math.floor( this.displaySpeed * rawTimeElapsed );
				    let lineColor = new THREE.Color( 0xe34f4f );
				    let splineInterpolationNum = 2;

				    if ( displayTimeElapsed <= this.shot.points.length ) {

				        let point = this.shot.points[ displayTimeElapsed ];        
				        if ( point == null ) {
				            return;
				        };

				        this.points.push( point.position.clone() );

						// Update screen data
				        this.statusElementTime.innerHTML = ( displayTimeElapsed / 1000 ).toFixed( 1 ) + ' s';
				        this.statusElementSpeed.innerHTML = point.velocity.length().toFixed( 1 ) + ' mps';
				        this.statusElementHeight.innerHTML = point.position.y.toFixed( 0 ) + ' p.y mt';
				        this.statusElementDistance.innerHTML = point.position.z.toFixed( 0 ) + ' p.z mt';
				        this.statusElementSpin.innerHTML = point.angularVelocity.length().toFixed( 0 ) + ' rpm';

				        //let ball = this.scene.getObjectByName( 'ball' );
				        this.ball3D.position.set( point.position.x, point.position.y, point.position.z + this.sceneZOffset );
				        this.ball3D.rotation.y =  ( point.angularVelocity.length() / 60 ) * displayTimeElapsed;
				        this.ball3D.rotation.z =  ( point.angularVelocity.length() / 600 ) * displayTimeElapsed;

				        this.ring.position.set( point.position.x, 0, point.position.z + this.sceneZOffset );

				    };
				};

			    getGrid( sizeX, sizeZ, step, color ) {

			        let geometry = new THREE.Geometry();
			        let material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, opacity: 0.2 } );

			        for ( let i = - sizeX; i <= sizeX; i += step ) {

			            for ( let j = - sizeZ; j <= sizeZ; j += step ) {

			                geometry.vertices.push(
			                    new THREE.Vector3( - sizeX, 0, j ), new THREE.Vector3( sizeX, 0, j ),
			                    new THREE.Vector3( i, 0, - sizeZ ), new THREE.Vector3( i, 0, sizeZ )
			                );

			                geometry.colors.push( color, color, color, color );

			            };

			        };

			        let grid = new THREE.LineSegments( geometry, material );

			        return grid;
			    };

				addInitialElements() {
				    
				    let scope = this;
				    let gridWidth = 60;
				    let gridHeight = 100;

				    this.sceneZOffset = -gridHeight/2.0;

				    // add ground grid
				    let gridColor = new THREE.Color( 0x69ba6d )
				    let grid = this.getGrid( gridWidth, gridHeight, 10, gridColor );

				    this.scene.add( grid );

				    // Add text
				    let loader = new THREE.FontLoader();
				    loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

				        // add marker indicators
				        let markerColor = 0x00ffff;
				        let textMesh = new THREE.MeshNormalMaterial();

				        let markerMeterage = 0;
				        while( markerMeterage <= gridHeight + 15 ) {

				            // text
				            let textGeometry = new THREE.TextGeometry( markerMeterage + "mt", {
				                size: 3,
				                height: 0.1,
				                curveSegments: 1,
				                font: font
				            });

				            textGeometry.computeBoundingBox();
				            textGeometry.computeVertexNormals();
				            
				            let words = new THREE.Mesh( textGeometry, textMesh );
				            words.position.x = gridWidth/2.0 + 5;
				            words.position.z = markerMeterage + scope.sceneZOffset - 0.5 * ( textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x );
				            words.rotation.y = -1 * Math.PI / 2;
				            scope.scene.add( words );

				            // line across grid
				            let pointA = new THREE.Vector3( -gridWidth/2.0, 0, markerMeterage + scope.sceneZOffset );
				            let pointB = new THREE.Vector3( gridWidth/2.0, 0, markerMeterage + scope.sceneZOffset );
				            let lineGeometry = new THREE.Geometry();
				            lineGeometry.vertices = [pointA, pointB];
				            let lineMaterial = new THREE.LineBasicMaterial( { color: markerColor, linewidth: 2 } );
				            let markerLine = new THREE.Line( lineGeometry, lineMaterial );
				            scope.scene.add( markerLine );

				            markerMeterage += 15;

				        };

				    });
						
			 		// --------- Soccer Ball ----------		
			     	let buffgeoSphere = new THREE.BufferGeometry();
			        buffgeoSphere.fromGeometry( new THREE.SphereGeometry( 1, 20, 10 ) );
				    let ballTexture = new THREE.TextureLoader().load( 'models/ball/ball.png' );			        
			        var ballMaterial = new THREE.MeshLambertMaterial({ 
			            color: 0xffffff, 
			            map: ballTexture
			        });
			        
			        this.ball3D = new THREE.Mesh( buffgeoSphere, ballMaterial );
			        
			        this.ball3D.castShadow = true;
			        this.ball3D.name = 'ball';

					//ball[i].receiveShadow = true;
					this.scene.add( this.ball3D );

					//------------ Ring -------------
					let ringGeom = new THREE.RingGeometry( 3, 7, 32 );
					let ringMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000, transparent: true, opacity: 0.5 } );

					this.ring = new THREE.Mesh( ringGeom, ringMaterial );
					this.ring.name = 'ring';
					this.ring.position.set( 0, 0, 0 );
					this.ring.rotation.x = -0.5 * Math.PI;

					this.scene.add( this.ring );

					//------------ GOAL ----------------
			    	let postLeft = new THREE.Mesh( new THREE.CylinderGeometry( 0.7, 0.7, 25.6, 32 ),
										    	new THREE.MeshLambertMaterial( { color: 0xffffff } ) );

			    	postLeft.position.set( 37.2, 12.8, 48 );
			    	this.scene.add( postLeft );
			    
			    	let postRight = postLeft.clone();
			    	postRight.position.set( -37.2, 12.8, 48 );
			    	this.scene.add( postRight );
			    
			    	let crossbar = new THREE.Mesh( new THREE.CylinderGeometry( 0.7, 0.7, 75, 32 ),
										    	new THREE.MeshLambertMaterial( { color: 0xffffff } ) );

			    	crossbar.rotation.z = Math.PI / 2;
			    	crossbar.position.set( 0, 25, 48 );
			    	this.scene.add( crossbar );

				};

			};

			//let scene3D = new Scene3D();

			class DragDrop3D extends Scene3D {
				
				constructor(){

					super();
					/*
					this.renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
					this.renderer.setSize( window.innerWidth, window.innerHeight );

					this.scene = new THREE.Scene();
					this.renderer.setClearColor( 0x333333 );
					this.camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 10, 1000 );
					this.camera.position.z = 60;
					this.camera.position.y = 30;
					this.camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
					this.camera.add( new THREE.PointLight( 0xffffff, 0.7 ) ); // point light at camera position
					this.scene.add( this.camera );
					this.scene.add( new THREE.DirectionalLight( 0xffffff,0.5 ) ); // light shining from above.
					this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
					this.controls.enabled = false;
					this.container = document.getElementById( "content" );
					*/

					this.ROTATE = 1;
					this.DRAG = 2;
					this.ADD = 3, 
					this.DELETE = 4, 
					this.ORBIT = 5;
					
					this.eventAction = this.DRAG;
					this.container.addEventListener( "mousedown", this.doEventStart.bind( this ) );
					this.container.addEventListener( "touchstart", this.doEventStart.bind( this ) );

					this.endCallback = null;
					this.cancelCallback = null;
					this.dragging = false;
					this.start = { x: 0, y: 0 };
					this.prev = { x: 0,	y: 0 };

					window.addEventListener( 'resize', function () {
						this.camera.aspect = window.innerWidth / window.innerHeight;
						this.camera.updateProjectionMatrix();
						//controls.handleResize();
						this.renderer.setSize( window.innerWidth, window.innerHeight );
					}.bind( this ), false );

					this.raycaster = new THREE.Raycaster();
					
					document.getElementById( "eventDrag" ).checked = true;
					document.getElementById( "eventRotate" ).onchange = this.doChangeEventAction.bind( this );
					document.getElementById( "eventDrag" ).onchange = this.doChangeEventAction.bind( this );
					document.getElementById( "eventAdd" ).onchange = this.doChangeEventAction.bind( this );
					document.getElementById( "eventDelete" ).onchange = this.doChangeEventAction.bind( this );

					this.createWorldContainer();
				
				};

				doChangeEventAction() {

					this.controls.enabled = false;

					if ( document.getElementById( "eventRotate" ).checked ) {
						this.eventAction = this.ROTATE;
					
					} else if ( document.getElementById( "eventDrag" ).checked ) {
						this.eventAction = this.DRAG;
					
					} else if ( document.getElementById( "eventAdd" ).checked ) {
						this.eventAction = this.ADD;
					
					} else {
						this.eventAction = this.DELETE;
					};

				};	
					
				createWorldContainer() {

					// An Object3D that contains all the mesh objects in the scene.
					// Rotation of the scene is done by rotating the world about its
					// y-axis.  (I couldn't rotate the camera about the scene since
					// the Raycaster wouldn't work with a camera that was a child
					// of a rotated object.)
					this.worldContainer = new THREE.Object3D();
					this.scene.add( this.worldContainer );

					this.ground = new THREE.Mesh(
						new THREE.BoxGeometry( 40, 1, 40 ),
						new THREE.MeshLambertMaterial( { color:"green" } )
					);

					this.ground.position.y = -0.5;  // top of base lies in the plane y = -5;
					this.worldContainer.add( this.ground );

					// An invisible object that is used as the target for raycasting while
					// dragging a cylinder.  I use it to find the new location of the
					// cylinder.  I tried using the ground for this purpose, but to get
					// the motion right, I needed a target that is at the same height
					// above the ground as the point where the user clicked the cylinder.
					this.targetForDragging = new THREE.Mesh(
						new THREE.BoxGeometry( 100, 0.01, 100 ),
						new THREE.MeshBasicMaterial()
					);

					this.targetForDragging.material.visible = false;

					//targetForDragging.material.transparent = true;  // This was used for debugging
					//targetForDragging.material.opacity = 0.1;
					//world.add(targetForDragging);

					this.cylinder = new THREE.Mesh(
						new THREE.CylinderGeometry( 1, 2, 6, 16, 32 ),
						new THREE.MeshLambertMaterial( { color:"yellow" } )
					);
					this.cylinder.position.y = 3;  // places base at y = 3;

					this.addCylinder( 10, 10 );
					this.addCylinder( 0, 15 );
					this.addCylinder( -15, -7 );
					this.addCylinder( -8, 5 );
					this.addCylinder( 5, -12 );

					this.worldContainer.add( this.ball3D );

				};

				addCylinder( x, z ) {

					let cylinderMesh = this.cylinder.clone();
					cylinderMesh.position.x = x;
					cylinderMesh.position.z = z;
					this.worldContainer.add( cylinderMesh );

					// The cylinder in Cannon is different than Three.js cylinder.
                	// We need to rotate it before attaching it to the mesh.
                	// CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded , thetaStart, thetaLength );

                	let cylinderShape = new CANNON.Cylinder( 1, 2, 6, 16 );
                	let quaternion = new CANNON.Quaternion();

                	quaternion.setFromAxisAngle( new CANNON.Vec3( 1, 0, 0 ), -Math.PI / 2 );

                	var translation = new CANNON.Vec3( 0, 0, 0 );
                	cylinderShape.transformAllPoints( translation, quaternion );

					// add cylinder
					let mass = 10;
					let cylinderBody = new CANNON.Body( mass );
					cylinderBody.addShape( cylinderShape );

					cylinderBody.position.set( x, 1, z );
					this.world.add( cylinderBody );

                    this.boxes.push( cylinderBody );
                    this.boxMeshes.push( cylinderMesh );

				};

				objectSelect( x, y ) {

					if ( this.eventAction == this.ROTATE ) {
						return true;
					};

			  		// I don't want to check for hits on targetForDragging
					if ( this.targetForDragging.parent == this.worldContainer ) {
						this.worldContainer.remove( this.targetForDragging );
					};

					let a = 2 * x / window.innerWidth - 1;
					let b = 1 - 2 * y / window.innerHeight;

					this.raycaster.setFromCamera( new THREE.Vector2( a, b ), this.camera );
					let intersects = this.raycaster.intersectObjects( this.worldContainer.children );

					if ( intersects.length == 0 ) {
						return false;
					};

					let item = intersects[ 0 ];
					let objectHit = item.object;
					let idx = this.boxMeshes.indexOf( objectHit );

					switch ( this.eventAction ) {

						case this.DRAG:

							if ( objectHit == this.ground ) {
								return false;
							} else {
								
							    if ( idx !== -1 ) {
									this.dragItemBody = this.boxes[ idx ];
							    };

								this.dragItem = objectHit;
								this.worldContainer.add( this.targetForDragging );
								this.targetForDragging.position.set( 0, item.point.y, 0 );
								return true;
							};

						case this.ADD:

							if ( objectHit == this.ground ) {

								// Gives the point of intersection in world coords
								let locationX = item.point.x;
								let locationZ = item.point.z;
								let coords = new THREE.Vector3( locationX, 0, locationZ );
								
								// to add cylider in correct position, neew local coords for the world object
								this.worldContainer.worldToLocal( coords );
								this.addCylinder( coords.x, coords.z );
							};
							return false;
						
						case this.DELETE: // DELETE

							if ( objectHit != this.ground ) {

							    if ( idx !== -1 ) {
							    	this.world.remove( this.boxes[ idx ] );
							    };

								this.worldContainer.remove( objectHit );
							};
							return false;
					};
				};

				objectMove( x, y ) {

					this.controls.enabled = false;

					if ( this.eventAction == this.ROTATE ) {

						let dx = x - this.prev.x;
						this.worldContainer.rotateY( dx / 200 );

					} else {  

						// drag
						let a = 2 * x / window.innerWidth - 1;
						let b = 1 - 2 * y / window.innerHeight;
						this.raycaster.setFromCamera( new THREE.Vector2( a, b ), this.camera );
						let intersects = this.raycaster.intersectObject( this.targetForDragging ); 

						if ( intersects.length == 0 ) {
							return;
						};

						let locationX = intersects[0].point.x;
						let locationZ = intersects[0].point.z;
						let coords = new THREE.Vector3( locationX, 0, locationZ );
						
						this.worldContainer.worldToLocal( coords );
						
						// clamp coords to the range -19 to 19, so object stays on ground
						a = Math.min( 19, Math.max( -19, coords.x ) );
						b = Math.min( 19, Math.max( -19, coords.z ) );
						
						this.dragItem.position.set( a, 3, b );
						this.dragItemBody.position.set( a, 3, b );
					};
				};

				doEventStart( event ) {
					
					if ( event.changedTouches ) {

						if ( event.touches.length != 1 ) {
							this.doEventEnd( event );
							return;
						};

					};
					
					event.preventDefault();

					if ( this.dragging ) {
						return;
					};

					let r = this.container.getBoundingClientRect();

					if ( event.changedTouches ) {

						var x = event.touches[ 0 ].clientX - r.left;
						var y = event.touches[ 0 ].clientY - r.top;

					} else {
				
						var x = event.clientX - r.left;
						var y = event.clientY - r.top;

					};
				
					this.prev.x = this.start.x = x;
					this.prev.y= this.start.x = y;
					this.dragging = this.objectSelect( x, y );

					let scope = this;

					if ( this.dragging ) {

						if ( event.changedTouches ) {
						
							this.container.addEventListener( "touchmove", scope.doEventMove.bind( this ) );
							this.container.addEventListener( "touchend", scope.doEventEnd.bind( this ) );
						
						} else {
						
							this.container.addEventListener( "mousemove", scope.doEventMove.bind( this ) );
							this.container.addEventListener( "mouseup", scope.doEventEnd.bind( this ) );
						
						};
					};
				};

				doEventMove( event ) {
				
					if ( this.dragging ) {

						if ( event.changedTouches ) {

							if ( event.touches.length != 1 ) {
								this.doEventEnd( event );
								return;
							};

						};

						event.preventDefault();
						let r = this.container.getBoundingClientRect();

						if ( event.changedTouches ) {
							var x = event.touches[ 0 ].clientX - r.left;
							var y = event.touches[ 0 ].clientY - r.top;
						
						} else {

							var x = event.clientX - r.left;
							var y = event.clientY - r.top;
						};

						this.objectMove( x, y );
						this.prev.x = x;
						this.prev.y = y;
					};
				};

				doEventEnd( event ) {
					
					this.controls.enabled = true;
					
					if ( this.eventAction == this.ROTATE ) {
						this.eventAction = this.DRAG;
						document.getElementById( "eventDrag" ).checked = true;
					};

					let scope = this;

					if ( this.dragging ) {

						this.dragging = false;
						
						if ( event.changedTouches ) {

							this.container.removeEventListener( "touchmove", scope.doEventMove.bind( this ) );
							this.container.removeEventListener( "touchend", scope.doEventEnd.bind( this ) );

						} else {

							this.container.removeEventListener( "mousemove", scope.doEventMove.bind( this ) );
							this.container.removeEventListener( "mouseup", scope.doEventEnd.bind( this ) );

						};
					};

					if ( this.endCallback ) {
						this.endCallback( event );
					};
									
					if ( this.cancelCallback ) {
						this.cancelCallback( event );
					
					};			

				};

				// CCD Continous Collision Detection
				// Must predict next position and check if the ray trajectory if it intersects anything!
				limitSphere( ball, objs ){
					var raycaster = new THREE.Raycaster();
			  		raycaster.set( ball.position.clone(), ball.velocity.clone().unit() );
			  		raycaster.far = ball.velocity.length();
			  		var arr = raycaster.intersectObjects( objs );

			  		if( arr.length ){
			    		ball.position.copy( arr[0].point );
			  		};
				};

			};

			let scene3D;
			document.addEventListener( "DOMContentLoaded", function( event ) {
				scene3D = new DragDrop3D();
			});

        </script>
    </body>
</html>

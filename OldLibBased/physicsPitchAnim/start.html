<!DOCTYPE html>
<html lang="en">
<head>
<title>xbe.at</title>

<style>
    body{ background-color: #3D4143; overflow: hidden; color:#EEEEEE; font-family:Arial; font-size: 11px;}
    canvas{ position: absolute; top:0; left:0; pointer-events:auto; width:100%; height:100%; }
</style>


<script src="https://sport.xbe.at/plus/three.js/build/three.min.js"></script>
<script src="https://sport.xbe.at/plus/three.js/example/js/controls/OrbitControls.js"></script>
<script src="https://sport.xbe.at/plus/three.js/examples/js/libs/stats.min.js"></script>
<!-- <script src="https://sport.xbe.at/three.js/examples/js/libs/dat.gui.min.js"></script> -->

<script src="https://sport.xbe.at/plus/three.js/examples/js/loaders/ColladaLoader.js"></script>
<script src="https://sport.xbe.at/plus/three.js/examples/js/loaders/collada/Animation.js"></script>
<script src="https://sport.xbe.at/plus/three.js/examples/js/loaders/collada/AnimationHandler.js"></script>
<script src="https://sport.xbe.at/plus/three.js/examples/js/loaders/collada/KeyFrameAnimation.js"></script>

<script src="https://sport.xbe.at/plus/Oimo.js-gh-pages/build/oimo.js"></script>

</head>
<body>
	<canvas id="canvas"></canvas>
	
	<!--
	<div id='interface'>
	    <input type="button" value="demo" onClick=populate(1)>
	    <input type="number" name="quantity" min="10" max="2000" value="6"  id='MaxNumber'>
	    <input type="submit" onClick=populate()>
	    <input type="number" name="gravity" min="-20" max="20" value="-10" id='gravity' onChange=gravity() >
	</div>
	<div id='info'></div>
	-->
	
	<!--
    <div id="field">
		<object data="https://sport.xbe.at/plus/svg/soccer_field.svg" type="image/svg+xml" width="520" height="345"></object>
		<div id="ball"></div>
	</div>  
	
	<div id="result"></div>
	-->
<script>

    var antialias = true;

    // three var
    var camera, scene, light, renderer, canvas, controls, content, stats;
    var meshs = [];
    var grounds = [];
    var paddle;
    var matBox, matSphere, matBoxSleep, matSphereSleep, matGround, matGroundTrans;
    var buffgeoSphere, buffgeoBox;
    var ray, mouse;
    var ToRad = Math.PI / 180;
    var ToDeg = 180 / Math.PI;
    var rotTest;
    var player = [], animation = [], playerOimo = [];
    var anim;

    //oimo var
    var world = null;
    var bodys = null;
    var infos;
    var type = 1;
    
    var clock = new THREE.Clock();
 
    init();
    loop();

    function init() {
        //var n = navigator.userAgent;

        //infos = document.getElementById("info");
        canvas = document.getElementById("canvas");

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 5000 );
        camera.position.set( -400, 160, 0 );

        controls = new THREE.OrbitControls( camera, canvas );
        controls.target.set(0, 20, 0);
        controls.update();

        ray = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer({ canvas:canvas, precision: "mediump", antialias:antialias });
        renderer.setSize( window.innerWidth, window.innerHeight );

        content = new THREE.Object3D();
        scene.add(content);

        var materialType = 'MeshBasicMaterial';
        
        
        //Stats
	    containerStats = document.createElement( 'div' );
	    document.body.appendChild( containerStats ); 
	    containerStats.appendChild( renderer.domElement );
	
	    stats = new Stats();
	    stats.domElement.style.position = 'absolute';
	    stats.domElement.style.top = '0px';
	    stats.domElement.style.zIndex = 100;
	    containerStats.appendChild( stats.domElement );
        
        //Scene
        scene.add( new THREE.AmbientLight( 0x3D4143 ) );
        light = new THREE.DirectionalLight( 0xffffff , 1);
        light.position.set( 300, 1000, 500 );
        light.target.position.set( 0, 0, 0 );
        light.castShadow = true;
        var d = 300;
        light.shadow.camera = new THREE.OrthographicCamera( -d, d, d, -d,  500, 1600 );
        light.shadow.bias = 0.0001;
        light.shadow.mapSize.width = light.shadow.mapSize.height = 1024;
        scene.add( light );
        materialType = 'MeshPhongMaterial';
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;

        // background
        
        var buffgeoBack = new THREE.BufferGeometry();
        buffgeoBack.fromGeometry( new THREE.IcosahedronGeometry(3000,1) );
        var back = new THREE.Mesh( buffgeoBack, new THREE.MeshBasicMaterial( { map:gradTexture([[1,0.75,0.5,0.25], ['#1B1D1E','#3D4143','#72797D', '#b0babf']]), side:THREE.BackSide, depthWrite: false }  ));
        back.geometry.applyMatrix(new THREE.Matrix4().makeRotationZ(15*ToRad));
        scene.add( back );

        buffgeoSphere = new THREE.BufferGeometry();
        buffgeoSphere.fromGeometry( new THREE.SphereGeometry( 1, 20, 10 ) );

        buffgeoBox = new THREE.BufferGeometry();
        buffgeoBox.fromGeometry( new THREE.BoxGeometry( 1, 1, 1 ) );

        matSphere = new THREE[materialType]( { map: basicTexture(0), name:'sph' } );
        matBox = new THREE[materialType]( {  map: basicTexture(2), name:'box' } );
        matSphereSleep = new THREE[materialType]( { map: basicTexture(1), name:'ssph' } );
        matBoxSleep = new THREE[materialType]( {  map: basicTexture(3), name:'sbox' } );
        matGround = new THREE[materialType]( { color: 0x3D4143, transparent:true, opacity:0.5 } );
        matGroundTrans = new THREE[materialType]( { color: 0x3D4143, transparent:true, opacity:0.6 } );

        paddle = new THREE.Object3D();
        rotTest = new THREE.Vector3();

        // events
        window.addEventListener( 'resize', onWindowResize, false );
        canvas.addEventListener( 'mousemove', rayTest, false);
        //canvas.onmousemove = rayTest;

        // physics
        initOimoPhysics();
    }
    
    function loop() {
        requestAnimationFrame( loop );
        updateOimoPhysics();
        renderer.render( scene, camera );
        THREE.AnimationHandler.update( clock.getDelta() );
        stats.update();
        anim.engine();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function clearMesh(){
        var i = meshs.length;
        while (i--) scene.remove(meshs[ i ]);
        i = grounds.length;
        while (i--) scene.remove(grounds[ i ]);
        grounds = [];
        meshs = [];
    }

    //----------------------------------
    //  OIMO PHYSICS
    //----------------------------------

    function initOimoPhysics(){

        world = new OIMO.World({info:true, worldscale:100});
        populate(1);
        //setInterval(updateOimoPhysics, 1000/60);
    };

    function populate(n) {

        // The Bit of a collision group
        var group1 = 1 << 0;  // 00000000 00000000 00000000 00000001
        var group2 = 1 << 1;  // 00000000 00000000 00000000 00000010
        var group3 = 1 << 2;  // 00000000 00000000 00000000 00000100
        var all = 0xffffffff; // 11111111 11111111 11111111 11111111

        var max = 1;//document.getElementById("MaxNumber").value;

        type = 3;

        // reset old
        clearMesh();
        world.clear();
        bodys = [];

        // Is all the physics setting for rigidbody
        var config = [
            1, // The density of the shape.
            0.4, // The coefficient of friction of the shape.
            0.2, // The coefficient of restitution of the shape.
            1, // The bits of the collision groups to which the shape belongs.
            all // The bits of the collision groups with which the shape collides.
        ];

        //add ground
        var ground = world.add({size:[1800, 40, 1400], pos:[0,-20,0], config:config});

        
        //add a player
        /*
        var playerOimoBlue = world.add({size:[10, 100, 100], pos:[1,10,10], rot:[0,0,0], config:config});
        var playerOimoRed = world.add({size:[10, 100, 100], pos:[1,10,45], rot:[0,0,0], config:config});
         
        buffgeoCylinder = new THREE.BufferGeometry();
        buffgeoCylinder.fromGeometry( new THREE.CylinderGeometry(1, 1, 6, 16, 32) );
        
       	player = new THREE.Mesh( buffgeoCylinder, new THREE.MeshLambertMaterial({ color: "blue" }) );
		player.position.y = 1;
		player.position.x = 10;
		player.position.z = 10;
		player.castShadow = true;
		player.receiveShadow = true;
		player.scale.x = player.scale.z = player.scale.y = 10;
		player.name = "Player#1";
		content.add( player );
		//grounds.push( player );
		
       	player = new THREE.Mesh( buffgeoCylinder, new THREE.MeshLambertMaterial({ color: "red" }) );
		player.position.y = 1;
		player.position.x = 10;
		player.position.z = 45;
		player.castShadow = true;
		player.receiveShadow = true;
		player.scale.x = player.scale.z = player.scale.y = 10;
		player.name = "Player#2";
		content.add( player );
        */
        
        //load pitch & player
	    var loader = new THREE.ColladaLoader();
	    loader.options.convertUpAxis = true;

		loader.load( 'models/archive/pitch/De+Nieuwe+Kuip_pitch.dae', function ( collada ) {
	        stadium = collada.scene;
	        stadium.scale.x = stadium.scale.y = stadium.scale.z = 0.5;
	     	stadium.rotation.y = 90 * (Math.PI / 180);
	     	//dae.rotation.x = 1 * (Math.PI / 180);
	     	stadium.position.z = 0;
	        stadium.updateMatrix();
	        content.add( stadium );
	
	    } );

		loader.load( 'models/archive/playerDAE/jog_forward2.dae', function ( collada ) {
			var playerObj = collada.scene;
		    for (var playerNum = 0; playerNum < 22; playerNum++) {
			
	    		player[playerNum] = playerObj.clone();      
				player[playerNum].traverse( function ( child ) {
					if ( child instanceof THREE.SkinnedMesh ) {
						animation[playerNum] = new THREE.Animation( child, child.geometry.animation );
						//if(i == 5) 
						animation[playerNum].play();
					}
				} );
		
				player[playerNum].scale.x = player[playerNum].scale.y = player[playerNum].scale.z = 0.2;
				player[playerNum].position.y = 0.5;
				//player[playerNum].position.x = 0.3*playerNum;
				player[playerNum].rotation.x = 90 * (Math.PI / 180);
				player[playerNum].castShadow = true;
				player[playerNum].receiveShadow = true;
				
				player[playerNum].updateMatrix();
				content.add( player[playerNum] );
				
				playerOimo[playerNum] = world.add({size:[10, 100, 100], pos:[1,10,10], rot:[0,0,0], move:true, noSleep:true, name:'player'+playerNum, kinematic:true, config:config});
				
				playerOimo[playerNum].setPosition(player[playerNum].position);
				
			}
			anim = new animate();		
		} );

        // now add object
        var x, y, z, w, h, d;
        var i = max;


        while (i--){
            if(type===3) t = Math.floor(Math.random()*2)+1;
            else t = type;
            x = 150;
            z = -100 + Math.random()*200;
            y = 100 + Math.random()*1000;
            w = 10 + Math.random()*10;
            h = 10 + Math.random()*10;
            d = 10 + Math.random()*10;

            config[4] = all;

            config[3] = group2;
            bodys[i] = world.add({type:'sphere', size:[w*0.5], pos:[x,y,z], move:true, config:config, name:'sphere'});
           
            var texture = THREE.ImageUtils.loadTexture('https://sport.xbe.at/plus/images/targets.png');  // Football.png			        
            //meshs[i] = new THREE.Mesh( buffgeoSphere, matSphere );
	        var material = new THREE.MeshLambertMaterial({ 
	            color: 0xffffff, 
	            map: texture
	        });
	        
	        meshs[i] = new THREE.Mesh( buffgeoSphere, material );
            meshs[i].scale.set( w/2, w/2, w/2 );
            
            meshs[i].castShadow = true;
			//meshs[i].receiveShadow = true;
			scene.add( meshs[i] );                

        }

        config[3] = 1;
        config[4] = all;
        bodys[max] = world.add({size:[20, 40, 60], pos:[-150,20,0], rot:[0,0,0], move:true, noSleep:true, config:config, name:'paddle', kinematic:true });
        meshs[max] = new THREE.Mesh( buffgeoBox, matBox );
        meshs[max].scale.set( 20, 40, 60 );
        scene.add( meshs[max] );
    }
   
    function updateOimoPhysics() {

        if(world == null) return;

        world.step();

        // apply new position on last rigidbody
        bodys[bodys.length-1].setPosition(paddle.position);

        paddle.lookAt(new THREE.Vector3(100,paddle.position.y, 0));
        paddle.rotation.y += 90*ToRad;

        // apply new rotation on last rigidbody
        bodys[bodys.length-1].setQuaternion(paddle.quaternion);        

        var p, r, m, x, y, z;
        var mtx = new THREE.Matrix4();
        var i = bodys.length;
        var mesh;
        var body;

        while (i--){
            body = bodys[i];
            mesh = meshs[i];

            if(!body.sleeping){

                mesh.position.copy(body.getPosition());
                mesh.quaternion.copy(body.getQuaternion());

                // change material
                if(mesh.material.name === 'sbox') mesh.material = matBox;
                if(mesh.material.name === 'ssph') mesh.material = matSphere; 

                // reset position
                if(mesh.position.y<-100){
                    x = 150;
                    z = -100 + Math.random()*200;
                    y = 100 + Math.random()*1000;
                    body.resetPosition(x,y,z);
                }
            } else {
                if(mesh.material.name === 'box') mesh.material = matBoxSleep;
                if(mesh.material.name === 'sph') mesh.material = matSphereSleep;
            }
        }

        // contact test
        if(world.checkContact('paddle', 'sphere')) meshs[bodys.length-1].material = matSphere;
        else if(world.checkContact('paddle', 'box')) meshs[bodys.length-1].material = matBox;
        else meshs[bodys.length-1].material = matBoxSleep;

        //infos.innerHTML = world.getInfo();
    }

    function gravity(g){
        nG = document.getElementById("gravity").value
        world.gravity = new OIMO.Vec3(0, nG, 0);
    }

    var unwrapDegrees = function (r) {
        r = r % 360;
        if (r > 180) r -= 360;
        if (r < -180) r += 360;
        return r;
    }

    //----------------------------------
    //  TEXTURES
    //----------------------------------

    function gradTexture(color) {
        var c = document.createElement("canvas");
        var ct = c.getContext("2d");
        c.width = 16; c.height = 256;
        var gradient = ct.createLinearGradient(0,0,0,256);
        var i = color[0].length;
        while(i--){ gradient.addColorStop(color[0][i],color[1][i]); }
        ct.fillStyle = gradient;
        ct.fillRect(0,0,16,256);
        var texture = new THREE.Texture(c);
        texture.needsUpdate = true;
        return texture;
    }

    function basicTexture(n){
        var canvas = document.createElement( 'canvas' );
        canvas.width = canvas.height = 64;
        var ctx = canvas.getContext( '2d' );
        var colors = [];
        if(n===0){ // sphere
            colors[0] = "#58AA80";
            colors[1] = "#58FFAA";
        }
        if(n===1){ // sphere sleep
            colors[0] = "#383838";
            colors[1] = "#38AA80";
        }
        if(n===2){ // box
            colors[0] = "#AA8058";
            colors[1] = "#FFAA58";
        }
        if(n===3){ // box sleep
            colors[0] = "#383838";
            colors[1] = "#AA8038";
        }
        ctx.fillStyle = colors[0];
        ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = colors[1];
        ctx.fillRect(0, 0, 32, 32);
        ctx.fillRect(32, 32, 32, 32);

        var tx = new THREE.Texture(canvas);
        tx.needsUpdate = true;
        return tx;
    }

    //----------------------------------
    //  RAY TEST
    //----------------------------------

    function rayTest(e) {
        mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

        ray.setFromCamera( mouse, camera );
        var intersects = ray.intersectObjects( content.children, true );
        if ( intersects.length) {
            paddle.position.copy( intersects[0].point.add(new THREE.Vector3( 0, 20, 0 )) );
        }
    }

	///////////////////////
	//animate
	function animate() {

		var minX = 35,
				maxX = 370,
				minY = 22,
				maxY = 205,
				minT = 2500,
				maxT = 8500;
	
		var easing = {
			// easing equation
			easeInOutSine: (function(t) {
				return -1 / 2 * (Math.cos(Math.PI * t) - 1);
			})			
		};
	
        var getRandomInt = function(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        };

        var playerParams = [];
	
		// init array
        for (var num = 0; num < 22; num++){
            playerParams[num] = {
                start: {
                    x: getRandomInt(minX, maxX),
                    y: getRandomInt(minX, maxX)
                },
                end: {
                    x: getRandomInt(minX, maxX),
                    y: getRandomInt(minY, maxY)
                },
                startTime: new Date().getTime(),
                duration: getRandomInt(minT, maxT)
            };
        };

		this.engine = function() {
			var now = new Date().getTime();

            for (var num = 0; num < 22; num++){

    			var timeNorm = (now - playerParams[num].startTime) / playerParams[num].duration;
                var completionNorm = easing.easeInOutSine(timeNorm);
                var diff = {
                    x: playerParams[num].end.x - playerParams[num].start.x,
                    y: playerParams[num].end.y - playerParams[num].start.y
                };

    			var posX = playerParams[num].start.x + completionNorm * diff.x;
    			var posY = playerParams[num].start.y + completionNorm * diff.y;

    			if (now - playerParams[num].startTime > playerParams[num].duration) {
                    playerParams[num].start.x = playerParams[num].end.x;     
                    playerParams[num].start.y = playerParams[num].end.y; 
    				playerParams[num].end.x = getRandomInt(minX, maxX);		
					playerParams[num].end.y = getRandomInt(minY, maxY);							
					playerParams[num].duration = getRandomInt(minT, maxT);
					playerParams[num].startTime = new Date().getTime();
         				
					player[num].rotation.z = getRandomInt(-180, 180) * (Math.PI / 180);
					player[num].updateMatrix();

    			} else {
    				
					player[num].position.set((posX*3)-25, 25, (posY*3)-15);
					playerOimo[num].setPosition(player[num].position);					
					player[num].updateMatrix();
    			}						
			};		
		}		
		
		/*		
		getPositionAtCenter = function(element) {
			var data = element.getBoundingClientRect();
			return {
				x: data.left + data.width / 2,
				y: data.top + data.height / 2
			};
		},
		
		getDistanceBetweenElements = function(a, b) {
			var aPosition = getPositionAtCenter(a);
			var bPosition = getPositionAtCenter(b);
			var distance = Math.sqrt(Math.pow(aPosition.x - bPosition.x, 2) + Math.pow(aPosition.y - bPosition.y, 2));
			document.getElementById("result").innerText = distance;
			return distance;
		};	
		*/
	
	};

</script>




</body>
</html>
